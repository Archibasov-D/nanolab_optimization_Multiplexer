# -*- coding: utf-8 -*-
"""MUX_gradient_numpy до попытки уширить область среднюю, чтобы при нормале было хорошее качество 5.04.2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t6adg4FlLuAct8pWDP-tBh06D9F9BOlX

#Построение начального приближения, чтобы выходное поле под нулём градусов.
"""

if N1%2==0: x_start = -(N1/2 -1)*T - T/2
else: x_start = -(N1-1)/2*T

if N1%2==0: x_stop = (N1/2 -1)*T + T/2
else: x_stop = (N1-1)/2*T

x_arr = np.linspace( x_start,x_stop , num =N1,endpoint=True)
y_arr = np.linspace( x_start,x_stop , num =N1,endpoint=True)

y_grid, x_grid = np.meshgrid(x_arr, y_arr)

def zero_angle_begin(vector):
  '''
  Создаёт узкую полоску фазы в области выходного поля

  N1, N2 - разные для полного выходного поля и фазовой маски
  '''
  #step = int((N2 - N_exit)/2) # от бока?
  vector = np.reshape(vector, (N1,N2))

  additional_2 = 40

  begin = 690
  end = 790

  vector[begin:end,N2//2 - additional_2 : N2//2 + additional_2  ] = np.angle(np.exp(-1j*k_wave*np.sin(incident_angle/2)*x_grid[begin:end,N2//2 - additional_2 : N2//2 + additional_2  ] ) )

  return np.reshape(vector, (N1*N2,))

plt.imshow(np.reshape(zero_angle_begin(parameter_vector), (N1,N2)))
plt.colorbar()
plt.title("фаза маски")
plt.show()
parameter_vector = zero_angle_begin(parameter_vector)

crush_system()

"""# TODO

**TODO:** 1) Написать функцию выходного поля
2) простроить таблицу как для демультиплексора

**Нужно писать без torch, постоянные конвертирования из одного типа данных в другие - это лишнее**



1.   Хочу изменить выходной угол поля на 2 градуса
2.   Новый пункт

**Объяснение кода и структуры проекта:**
Все расстояния взяты из оригинальной статьи


  **1.**Угол вхождения простых мод равен 12 градусам, как в статье

  **2.**Угол выхода либо ставить 0 как в статье, но тогда начинать с х0 где будет отражательный фазовый профиль, чтобы не возникало проблемы с поле отраженным от выходного отверстия. Либо задать выходной угол не равным нулю.


  **3.** В Фурье используются N_full, а вектор параметров оптимизации задаётся через N1, N2

  **4.** Входные поля для фурье имеют вид матрицы, чтобы удобно было считать распространение. Выходные поля имеют вид вектора чтобы было удобно счиать функцию потерь. Оба вида полей нормированы на 1 при полноразмерном формате фурье.


  TODO: Получилось что моды не ортогональны! Нужно решить эту проблему
"""

def crush_system():
  pupa = np.random.rand(N1_full**2, N1_full**2)

"""#Введение констант, подбор расстояния"""

import numpy as np
import matplotlib.pyplot as plt
from numpy.linalg import inv
import cmath
from scipy.linalg import dft
import torch
import scipy as sp
from PIL import Image, ImageChops, ImageFilter
import math
import matplotlib as mpl
from scipy.optimize import minimize
from scipy.optimize import differential_evolution
from scipy.fft import fft, ifft

import matplotlib as mpl
import matplotlib.ticker as ticker
from  scipy.special import hermite

n = 1.4440 #на данной длине волны
wave_length = 1550/n * 1e-9
N1 = 800# x - это без учёта заглушки
N2 = 800# y
N_padding = 140
N_exit = 50
N_input = 30
N_step_boudary = 10

N1_full = N1 + 2*N_padding
N2_full = N2 + 2*N_padding


T = 1 * 1e-6 #0.7*wave_length
k_wave = 2*np.pi/wave_length
d = 525 * 1e-6
incident_angle = np.pi/15 #12 градусов




# расчёт матрицы
#нужно описать пропогаторы
#получение фурье матрицы
# определение пропогатора
fX = np.fft.fftfreq(N1_full,T) #fY идентичны - Правильно сделано, возвращает 1/м
fY = np.fft.fftfreq(N2_full,T) # fX.copy()
H_propogator_d=np.zeros((N1_full,N2_full),dtype='complex')
for i in range(N1_full):
  for j in range(N2_full):
    H_propogator_d[i,j] = np.exp(1j*k_wave*d*cmath.sqrt(1-np.power(wave_length*fX[i],2)-np.power(wave_length*fY[j],2))) # квадрат i j поменял местами

parameter_vector= (N1*N2)*[np.pi]#(2*np.pi)*np.random.rand(N1*N2) # нужно чтобы оптимизировать ортогональные моды - очевидное решение
parameter_vector = np.array(parameter_vector)

"""# Задание источников и целей"""

def normalize_matrix(U_matrix,N1,N2):
  """
  Возвращаетматрицу нормированную на энергию и прежнюю норму (матрица как вектор, обычная евклидовая норма)

  """
  norma = np.sqrt(np.absolute(np.matmul(np.conj(np.reshape(U_matrix,(N1*N2,1))).T, np.reshape(U_matrix,(N1*N2,1)))))
  return U_matrix/float(norma)#, float(norma )

def normalize_vector(U_vector):
  """
  Возвращает вектор нормированный на энергию и прежнюю норму
  переписано для numpy
  """
  norma = np.sqrt(np.absolute(np.matmul(np.conj(U_vector).T, U_vector))) #[0] может понадобится
  return U_vector/norma, float(norma )

"""**Пока что будем задавать источники через формулы, так как Гауссы**

## Задание мод
"""

def exit_modes(N_exit,radius, n,m, matrix_x,matrix_y):
  '''
  вначале будем считать перетяжка и фронт плоский
  -> w0, R =0

  НЕ ОПРЕДЕЛИЛСЯ ЧЕМУ СООТВЕТСВУЮТ n,m - x,y !!!!!!!!!!!!!!!!!!!!!!!!!!!!!


  arctan(0) = 0
  '''
  hermit_n = hermite(n )
  hermit_m = hermite(m)


  Herm_matrix_n = np.zeros((N_exit, N_exit))
  Herm_matrix_m = np.zeros((N_exit, N_exit))


  for i in range(N_exit):
    for j in range(N_exit):
      Herm_matrix_n[i,j] = hermit_n(np.sqrt(2)*matrix_x[i,j]/radius)



  for i in range(N_exit):
    for j in range(N_exit):
      Herm_matrix_m[i,j] = hermit_m(np.sqrt(2)*matrix_y[i,j]/radius)

  return np.multiply(np.multiply(Herm_matrix_n, np.exp( - np.power(matrix_x, 2)/radius**2)), np.multiply(Herm_matrix_m, np.exp( - np.power(matrix_y, 2)/radius**2)) )

#создание сетки для выхода
if N_exit%2==0: x_start = -(N_exit/2 -1)*T - T/2
else: x_start = -(N_exit-1)/2*T

if N_exit%2==0: x_stop = (N_exit/2 -1)*T + T/2
else: x_stop = (N_exit-1)/2*T

x_arr = np.linspace( x_start,x_stop , num =N_exit,endpoint=True)
y_arr = np.linspace( x_start,x_stop , num =N_exit,endpoint=True)

y_grid, x_grid = np.meshgrid(x_arr, y_arr)

#опредление мод выходных

width_smal = 9
width_big = 10
step = 6

grid_0_plus = step*T*np.ones((N_exit,N_exit))
grid_0_minus = -step*T*np.ones((N_exit,N_exit))

####### Здесь задаются выходные поля, добавил угол падения - 6 градусов
 #####
  ###
   #
   #
   # ЭТО БЫЛИ СТАРЫЕ ПРИБЛИЖЕННЫЕ МОДЫ
#U_output_1 = (np.exp(-(np.power(x_grid - grid_0_plus, 2)+np.power(y_grid, 2))/(T*width_smal)**2) - np.exp(-(np.power(x_grid - grid_0_minus, 2)+np.power(y_grid, 2))/(T*width_smal)**2)) *np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)
#U_output_2 = np.exp(-(np.power(x_grid, 2)+np.power(y_grid, 2))/(T*width_big)**2)*np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)
#U_output_3 = (np.exp(-(np.power(x_grid, 2)+np.power(y_grid - grid_0_plus , 2))/(T*width_smal)**2) - np.exp(-(np.power(x_grid, 2)+np.power(y_grid - grid_0_minus, 2))/(T*width_smal)**2)) *np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)

# фазовая часть нужна для угла у выходного поля
U_output_1 = exit_modes(N_exit,T*width_big, 1,0, x_grid,y_grid)*np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)
U_output_3 = exit_modes(N_exit,T*width_big, 0,1, x_grid,y_grid)*np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)
U_output_2 = exit_modes(N_exit,T*width_big, 0,0, x_grid,y_grid)*np.exp(1j*k_wave*np.sin(incident_angle/2)*x_grid)

"""**Задание ориентации** !!!!"""

plt.imshow(y_grid)
plt.colorbar()
plt.show()

plt.imshow(np.absolute(normalize_matrix(U_output_3, N_exit,N_exit)) )
plt.colorbar()
plt.title('Хотим на выходе при третьей моде')
plt.show()

#создание сетки для входа
if N_input%2==0: x_start = -(N_input/2 -1)*T - T/2
else: x_start = -(N_input-1)/2*T

if N_input%2==0: x_stop = (N_input/2 -1)*T + T/2
else: x_stop = (N_input-1)/2*T

x_arr = np.linspace( x_start,x_stop , num =N_input,endpoint=True)
y_arr = np.linspace( x_start,x_stop , num =N_input,endpoint=True)

y_grid, x_grid = np.meshgrid(x_arr, y_arr)

width_in = 8

U_input_gauss = np.exp(-(np.power(x_grid, 2)+np.power(y_grid, 2))/(T*width_in)**2)*np.exp(1j*k_wave*np.sin(incident_angle)*x_grid) #под углом должен быть ?????

plt.imshow(np.absolute(normalize_matrix(U_input_gauss, N_input,N_input) ))
plt.colorbar()
plt.show()

#Построение графиков для презентации


step = 4

scaler = 1e+6

tiks_place_x = np.linspace(0+step,N_input-step,5, endpoint=True, dtype=int)
tiks_place_y = np.linspace(0+step,N_input - step,5, endpoint=True, dtype=int)


tiks_value_x = np.round(np.linspace((-N_input/2 + step)*T*scaler,(N_input/2 - step)*T*scaler ,5, endpoint=True ), decimals=-0)
tiks_value_y = np.round(np.linspace((-N_input/2 + step)*T*scaler,(N_input/2 - step)*T*scaler, 5, endpoint=True), decimals=-0)



fig, ax = plt.subplots(figsize=(8,8),layout='tight')
ax.yaxis.set_major_locator(ticker.FixedLocator(tiks_place_y))
ax.yaxis.set_major_formatter(ticker.FixedFormatter(tiks_value_y))
ax.xaxis.set_major_locator(ticker.FixedLocator(tiks_place_x))
ax.xaxis.set_major_formatter(ticker.FixedFormatter(tiks_value_x))
ax.set_ylabel('y, мкм')
ax.set_xlabel('x, мкм')
map = ax.imshow(np.absolute(U_input_gauss) )
fig.colorbar(map,shrink=0.72)
#ax.set_title('фазовая маска')
plt.show()

"""**После того как определили поля, нужно задать полную картинку** - удобно делать через функцию, чтобы потом легко переписать"""

def generator_initial_field(U_mode, number_mode):
  """
  Возвращает ndarray, полноразмерный
  number_mode = {1, 2, 3}
  """
####### Вношу изменения чтобы увеличить расстояние между входными модами
 #####
  ###
   #
   #
  background = np.zeros((N1_full,N2_full), dtype='complex')

  # Ввожу два парметра для координаты у: сдвиг от борта и между модами
  N2_boundary_step = 130
  step_in_between =int((N2 - 2*N2_boundary_step - 3*N_input)/2) #int((N2 - 3*N_input)/4) + 15 # подгонка ??!!!!!
  if number_mode == 1:
    background[N_padding +  N_step_boudary: N_padding +N_step_boudary + N_input, N_padding + N2_boundary_step: N_padding + N2_boundary_step + N_input ] = U_mode
  if number_mode == 2:
    background[  N_padding +  N_step_boudary: N_padding +N_step_boudary + N_input, N_padding + N2_boundary_step + N_input + step_in_between: N_padding + N2_boundary_step + step_in_between +2*N_input] = U_mode
  if number_mode == 3:
    background[  N_padding +  N_step_boudary: N_padding +N_step_boudary + N_input, N_padding + N2_boundary_step + 2*step_in_between +2*N_input : N_padding + N2_boundary_step + 2*step_in_between +3*N_input ] = U_mode
  return background

plt.imshow(np.absolute(generator_initial_field(U_input_gauss, 1)+ generator_initial_field(U_input_gauss, 2)+generator_initial_field(U_input_gauss, 3)))
plt.colorbar()
plt.show()
plt.imshow(np.absolute(generator_initial_field(U_input_gauss, 1)+ generator_initial_field(U_input_gauss, 2)+generator_initial_field(U_input_gauss, 3))[90:140,420:500] )
plt.colorbar()
plt.show()

def generator_target_field(U_mode):
  """
  Возвращает ndarray, полноразмерный
  """
  background_exit = np.zeros((N1_full,N2_full), dtype='complex')
  step = int((N2 - N_exit)/2)

  background_exit[ N1_full - (N_step_boudary + N_exit + N_padding) : N1_full - (N_step_boudary + N_padding), N_padding +  step : N_padding +  step + N_exit] = U_mode
  return background_exit

plt.imshow(np.absolute(generator_target_field(U_output_1)))
plt.colorbar()
plt.show()
plt.imshow(np.absolute(generator_target_field(U_output_1))[800:950, 400:550])
plt.colorbar()
plt.show()

"""##Задание векторов целей"""

U_input_gauss_1_full = normalize_matrix(generator_initial_field(U_input_gauss, 1),N1_full,N2_full)
U_input_gauss_2_full = normalize_matrix(generator_initial_field(U_input_gauss, 2),N1_full,N2_full)
U_input_gauss_3_full = normalize_matrix(generator_initial_field(U_input_gauss, 3),N1_full,N2_full)


U_output_1_full,_ = normalize_vector(np.reshape(generator_target_field(U_output_1),(N1_full*N2_full,1)))
U_output_2_full,_ = normalize_vector(np.reshape(generator_target_field(U_output_2),(N1_full*N2_full,1)))
U_output_3_full,_ = normalize_vector(np.reshape(generator_target_field(U_output_3),(N1_full*N2_full,1)))

"""# Построение модели

##Создание фазовых масок
"""

# создание "ликалов" для фазовой маски
press = np.absolute(np.ones((N1_full,N2_full)) - (generator_initial_field(np.ones((N_input,N_input)),1)+ generator_initial_field(np.ones((N_input,N_input)),2) + generator_initial_field(np.ones((N_input,N_input)),3) ))
press = press[N_padding:N_padding+N1, N_padding:N_padding+N2]

plt.imshow(press)
plt.colorbar()
plt.title("press")
plt.show()

def T_phase(parameter_):
  """
  Создаёт фазовую маску, неоптимальным способом
  на вход: ndarray (N,)

  часть кода взята с generator_initial_field(), для соответствия - можно использовать для создания шаблона, как внешней переменной!
  """
  phase_mask = np.exp(1j*np.reshape(parameter_,(N1,N2)) )
  phase_mask_with_holes = np.multiply(phase_mask, press)
  T_phase = np.zeros((N1_full,N2_full), dtype='complex')
  T_phase[N_padding:N_padding+N1, N_padding:N_padding+N2] = phase_mask_with_holes
  return T_phase

plt.imshow(np.angle(T_phase((2*np.pi)*np.random.rand(N1*N2))))
plt.colorbar()
plt.title("фаза маски")
plt.show()

plt.imshow(np.absolute(T_phase((2*np.pi)*np.random.rand(N1*N2))))
plt.colorbar()
plt.title("амплитуда маски")
plt.show()

def T_mirror(parameter_):
  """
  Зеркальная сторона
  """
  press_exit = np.absolute(np.ones((N1_full,N2_full)) - (generator_target_field(np.ones((N_exit,N_exit))) ))
  press_exit = press_exit[N_padding:N_padding+N1, N_padding:N_padding+N2]

  mirror = np.ones((N1,N2))
  mirror_with_exit = np.multiply(mirror, press_exit)
  T_phase = np.zeros((N1_full,N2_full), dtype='complex')
  T_phase[N_padding:N_padding+N1, N_padding:N_padding+N2] = mirror_with_exit
  return T_phase

plt.imshow(np.absolute(T_mirror(parameter_vector)))
plt.colorbar()
plt.title("амплитуда зеркала")
plt.show()

generator_for_adjoint = np.absolute(generator_initial_field(np.ones((N_input,N_input)),1)+ generator_initial_field(np.ones((N_input,N_input)),2) + generator_initial_field(np.ones((N_input,N_input)),3) )
plt.imshow(generator_for_adjoint)
plt.title("Нужно чтобы получать выход с обратной стороны для сопряженного поля")
plt.colorbar()
plt.show()

plt.imshow(np.absolute(generator_target_field(np.ones((N_exit,N_exit)))))
plt.title("Нужно чтобы получать выход поля")
plt.colorbar()
plt.show()

"""##Комбинация в систему"""

def Propogator_MUX(parameter_, field):
  """
  на вход: ndarray (n,) и ndarray (N1_full,N2_full)
  будет доступ к внешним переменным
  выход: матрица размера (N1_full,N2_full)

  FFT -> Propagator(d) -> iFFT
  """
  # Фурье пропогатор:
  after_fft = fft(fft(field, axis = 0), axis = 1)
  propagated = np.multiply(after_fft, H_propogator_d)
  result = ifft(ifft(propagated, axis = 0), axis = 1)

  return result

def Propogator_MUX_adjoint(parameter_, field):
  """
  на вход: ndarray (n,) и ndarray (N1_full,N2_full)
  будет доступ к внешним переменным
  выход: матрица размера (N1_full,N2_full)

  FFT -> Propagator(d)_conj -> iFFT
  """
  # Фурье пропогатор:
  after_fft = fft(fft(field, axis = 0), axis = 1)
  propagated = np.multiply(after_fft, np.conj(H_propogator_d) )
  result = ifft(ifft(propagated, axis = 0), axis = 1)

  return result

def MUX_N3(parameter_, field_initial):
  """
  Описывает расспространение поля в системе,
  на выходе даёт вектор ndarray (N1_full*N2_full, 1)

  на вход ndarray (n,)
  использует также начальное поле как ndarray (N1_full, N2_full)

  всего 7 распространений
  """
  field_initial_1 = np.multiply(Propogator_MUX(parameter_, field_initial),T_mirror(parameter_))
  field_initial_2 = np.multiply(Propogator_MUX(parameter_, field_initial_1),T_phase(parameter_))
  field_initial_3 = np.multiply(Propogator_MUX(parameter_, field_initial_2),T_mirror(parameter_))
  field_initial_4 = np.multiply(Propogator_MUX(parameter_, field_initial_3),T_phase(parameter_))
  field_initial_5 = np.multiply(Propogator_MUX(parameter_, field_initial_4),T_mirror(parameter_)) # неэффективно с памятью !
  field_initial_6 = np.multiply(Propogator_MUX(parameter_, field_initial_5),T_phase(parameter_))
  field_initial_7 = np.multiply(Propogator_MUX(parameter_, field_initial_6),generator_target_field(np.ones((N_exit,N_exit))))

  return np.reshape(field_initial_7,(N1_full*N2_full,1))



def MUX_N3_adjoint_with_phase(parameter_, field_target):
  """
  СОПРЯЖЕННЫЙ MUX, возврщает полное большое поле с лицевой стороны
  """

  field_target = np.reshape(field_target,(N1_full, N2_full))

  field_initial_6 = np.multiply(Propogator_MUX_adjoint(parameter_, field_target),np.conjugate(T_phase(parameter_)))
  field_initial_5 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_6),np.conjugate(T_mirror(parameter_)))
  field_initial_4 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_5),np.conjugate(T_phase(parameter_)))
  field_initial_3 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_4),np.conjugate(T_mirror(parameter_)))
  field_initial_2 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_3),np.conjugate(T_phase(parameter_)))
  field_initial_1 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_2),np.conjugate(T_mirror(parameter_)))
  field_initial_0 = np.multiply(Propogator_MUX_adjoint(parameter_, field_initial_1),  generator_for_adjoint)


  return np.reshape(field_initial_0,(N1_full*N2_full,1))

def MUX_N3_chek__(parameter_, field_initial):
  """
  Описывает расспространение поля в системе до непосредственного выхода
  Для анализа системы
  """
  field_initial_1 = np.multiply(Propogator_MUX(parameter_, field_initial),T_mirror(parameter_))
  field_initial_2 = np.multiply(Propogator_MUX(parameter_, field_initial_1),T_phase(parameter_))
  field_initial_3 = np.multiply(Propogator_MUX(parameter_, field_initial_2),T_mirror(parameter_))
  field_initial_4 = np.multiply(Propogator_MUX(parameter_, field_initial_3),T_phase(parameter_))
  field_initial_5 = np.multiply(Propogator_MUX(parameter_, field_initial_4),T_mirror(parameter_)) # неэффективно с памятью !
  field_initial_6 = np.multiply(Propogator_MUX(parameter_, field_initial_5),T_phase(parameter_))
  field_initial_7 = Propogator_MUX(parameter_, field_initial_6)

  return field_initial_7

def overlap_integral_3_modes(parameter_):
  betha =1
  U_1 = MUX_N3(parameter_, U_input_gauss_1_full)
  U_2 = MUX_N3(parameter_, U_input_gauss_2_full)
  U_3 = MUX_N3(parameter_, U_input_gauss_3_full)

  return (-float((np.real(np.multiply(np.matmul(np.conj(U_output_1_full).T, U_1), np.matmul(np.conj(U_1).T, U_output_1_full)) ))[0,0]) -betha*float((np.real(np.multiply(np.matmul(np.conj(U_output_2_full).T, U_2), np.matmul(np.conj(U_2).T, U_output_2_full)) ))[0,0]) -float((np.real(np.multiply(np.matmul(np.conj(U_output_3_full).T, U_3), np.matmul(np.conj(U_3).T, U_output_3_full)) ))[0,0]) )/3

print(overlap_integral_3_modes(parameter_vector))

plt.imshow(np.absolute(np.reshape(MUX_N3(parameter_vector, U_input_gauss_1_full), (N1_full,N2_full))))
plt.colorbar()
plt.title("Проверка выхода из системы")
plt.show()

plt.imshow(np.absolute(np.reshape(MUX_N3_adjoint_with_phase(parameter_vector, np.reshape(U_output_3_full,((N1_full,N2_full)))), (N1_full,N2_full))))
plt.colorbar()
plt.title("Проверка выхода из системы сопряженного поля")
plt.show()

"""**Объяснение откуда рябь: почти в самом конце пучок залазит в мертвую зону, следовательно часть его обнуляется -> меняется профиль появляются прямоугольные границы -> широкий спектр -> фурье уже неточное**"""

plt.imshow(np.absolute(MUX_N3_chek__(parameter_vector, U_input_gauss_1_full)))
plt.title("Проверка распространения в системе")
plt.colorbar()
plt.show()

"""## Расчёт градиента

**ОШИБКА С НАЗВАНИЕМ ПЕРЕМЕННОЙ!!!!!!!!**
"""

def grad_MUX_visualisation(parameter_):
  """
  версия от 04.03.2025
  принимает ndarray (n,)
  возвращает ndarray (n,)
  """
  U_1 = MUX_N3(parameter_, U_input_gauss_1_full)
  U_2 = MUX_N3(parameter_, U_input_gauss_2_full)
  U_3 = MUX_N3(parameter_, U_input_gauss_3_full)

  U_1_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_1_full),T_mirror(parameter_)))
  U_1_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_1_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step2, T_phase(parameter_))),T_mirror(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_1_step1),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step1')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step2),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step2')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step3),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step3')
  plt.show()

  U_1_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_1_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_1_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_1_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_1_step3_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step3_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step2_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step2_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step1_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('1_step1_conj')
  plt.show()

  U_2_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_2_full),T_mirror(parameter_)))
  U_2_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_2_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step2, T_phase(parameter_))),T_mirror(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_2_step1),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step1')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_2_step2),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step2')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_2_step3),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step3')
  plt.show()

  U_2_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_2_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_2_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_2_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_2_step3_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step3_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_2_step2_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step2_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_2_step1_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('2_step1_conj')
  plt.show()

  U_3_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_3_full),T_mirror(parameter_)))
  U_3_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_3_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step2, T_phase(parameter_))),T_mirror(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_3_step1),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step1')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_3_step2),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step2')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_3_step3),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step3')
  plt.show()

  U_3_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_3_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_3_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_3_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))

  plt.imshow( np.reshape(np.absolute(U_3_step3_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step3_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_3_step2_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step2_conj')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_3_step1_conj),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('3_step1_conj')
  plt.show()



  part_1=np.multiply(np.matmul(np.conjugate(U_1).T, U_output_1_full ), (np.multiply(np.conjugate(U_1_step1_conj),U_1_step1) + np.multiply(np.conjugate(U_1_step2_conj),U_1_step2) + np.multiply(np.conjugate(U_1_step3_conj),U_1_step3) ))
  part_2=np.multiply(np.matmul(np.conjugate(U_2).T, U_output_2_full ), (np.multiply(np.conjugate(U_2_step1_conj),U_2_step1) + np.multiply(np.conjugate(U_2_step2_conj),U_2_step2) + np.multiply(np.conjugate(U_2_step3_conj),U_2_step3) ))
  part_3=np.multiply(np.matmul(np.conjugate(U_3).T, U_output_3_full ), (np.multiply(np.conjugate(U_3_step1_conj),U_3_step1) + np.multiply(np.conjugate(U_3_step2_conj),U_3_step2) + np.multiply(np.conjugate(U_3_step3_conj),U_3_step3) ))




  return  np.array(np.reshape((2*np.imag(part_1 + part_3 + part_3  )/3)[N_padding:N_padding+N1, N_padding:N_padding+N2], (N1*N2,))) # ОШИБКА , НЕ ТА РАЗМЕРНОСТЬ

#Коэф betha чтобы уравновестить градиенты с разных сторон

def grad_MUX(parameter_):
  """
  версия от 04.03.2025
  принимает ndarray (n,)
  возвращает ndarray (n,)
  """
  betha = 1

  U_1 = MUX_N3(parameter_, U_input_gauss_1_full)
  U_2 = MUX_N3(parameter_, U_input_gauss_2_full)
  U_3 = MUX_N3(parameter_, U_input_gauss_3_full)

  U_1_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_1_full),T_mirror(parameter_)))
  U_1_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_1_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_1_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_1_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_1_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_1_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))



  U_2_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_2_full),T_mirror(parameter_)))
  U_2_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_2_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_2_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_2_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_2_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_2_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))



  U_3_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_3_full),T_mirror(parameter_)))
  U_3_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_3_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_3_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_3_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_3_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_3_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))





  part_1=np.multiply(np.matmul(np.conjugate(U_1).T, U_output_1_full ), (np.multiply(np.conjugate(U_1_step1_conj),U_1_step1) + np.multiply(np.conjugate(U_1_step2_conj),U_1_step2) + np.multiply(np.conjugate(U_1_step3_conj),U_1_step3) ))
  part_2=np.multiply(np.matmul(np.conjugate(U_2).T, U_output_2_full ), (np.multiply(np.conjugate(U_2_step1_conj),U_2_step1) + np.multiply(np.conjugate(U_2_step2_conj),U_2_step2) + np.multiply(np.conjugate(U_2_step3_conj),U_2_step3) ))
  part_3=np.multiply(np.matmul(np.conjugate(U_3).T, U_output_3_full ), (np.multiply(np.conjugate(U_3_step1_conj),U_3_step1) + np.multiply(np.conjugate(U_3_step2_conj),U_3_step2) + np.multiply(np.conjugate(U_3_step3_conj),U_3_step3) ))




  return  np.array(np.reshape((2*np.imag( part_1 + part_2 + betha*part_3 )/3)[N_padding:N_padding+N1, N_padding:N_padding+N2], (N1*N2,))) # Тут была ошибка с отсутствием part 2

def grad_MUX_normalized(parameter_):
  """
  версия от 25.03.2025
  принимает ndarray (n,)
  возвращает ndarray (n,)
  каждый из вкладов от 3 мод, нормирован на единицу
  """

  betha = 1e-4

  U_1 = MUX_N3(parameter_, U_input_gauss_1_full)
  U_2 = MUX_N3(parameter_, U_input_gauss_2_full)
  U_3 = MUX_N3(parameter_, U_input_gauss_3_full)

  U_1_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_1_full),T_mirror(parameter_)))
  U_1_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_1_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_1_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_1_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_1_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_1_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_1_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))



  U_2_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_2_full),T_mirror(parameter_)))
  U_2_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_2_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_2_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_2_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_2_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_2_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))



  U_3_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_3_full),T_mirror(parameter_)))
  U_3_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_3_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_3_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_3_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_3_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_3_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_3_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_3_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))





  part_1=np.multiply(np.matmul(np.conjugate(U_1).T, U_output_1_full ), (np.multiply(np.conjugate(U_1_step1_conj),U_1_step1) + np.multiply(np.conjugate(U_1_step2_conj),U_1_step2) + np.multiply(np.conjugate(U_1_step3_conj),U_1_step3) ))
  part_2=np.multiply(np.matmul(np.conjugate(U_2).T, U_output_2_full ), (np.multiply(np.conjugate(U_2_step1_conj),U_2_step1) + np.multiply(np.conjugate(U_2_step2_conj),U_2_step2) + np.multiply(np.conjugate(U_2_step3_conj),U_2_step3) ))
  part_3=np.multiply(np.matmul(np.conjugate(U_3).T, U_output_3_full ), (np.multiply(np.conjugate(U_3_step1_conj),U_3_step1) + np.multiply(np.conjugate(U_3_step2_conj),U_3_step2) + np.multiply(np.conjugate(U_3_step3_conj),U_3_step3) ))




  return  betha*np.array(np.reshape((2*np.imag( normalize_matrix(part_1,N1_full,N2_full) + normalize_matrix(part_2,N1_full,N2_full) + normalize_matrix(part_3,N1_full,N2_full) )/3)[N_padding:N_padding+N1, N_padding:N_padding+N2], (N1*N2,))) # Тут была ошибка с отсутствием part 2

"""**Для проверки входов и зависимости от мод**"""

def grad_MUX1_gauss_mode(parameter_):
  """
  версия от 06.03.2025
  принимает ndarray (n,)
  возвращает ndarray (N1_full*N2_full, 1)

  Нужно чтобы конвертировать Гаусс с розличных точек в Гаусс

  """
  U_2 = MUX_N3(parameter_, U_input_gauss_3_full)

  U_2_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_3_full),T_mirror(parameter_)))
  U_2_step2 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_2_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_2_step2, T_phase(parameter_))),T_mirror(parameter_)))



  U_2_step3_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.reshape(U_output_2_full, (N1_full,N2_full))), np.conjugate(T_phase(parameter_)))
  U_2_step2_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step3_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))
  U_2_step1_conj = np.multiply(Propogator_MUX_adjoint(parameter_, np.multiply(Propogator_MUX_adjoint(parameter_, U_2_step2_conj), np.conjugate(T_mirror(parameter_)))), np.conjugate(T_phase(parameter_)))

  part_2=np.multiply(np.matmul(np.conjugate(U_2).T, U_output_2_full ), (np.multiply(np.conjugate(U_2_step1_conj),U_2_step1) + np.multiply(np.conjugate(U_2_step2_conj),U_2_step2) + np.multiply(np.conjugate(U_2_step3_conj),U_2_step3) ))



  return  np.array(np.reshape((2*np.imag(part_2))[N_padding:N_padding+N1, N_padding:N_padding+N2], (N1*N2,)))

def overlap_integral_1_gauss_mode(parameter_):
  """
  Нужно, чтобы проверить влияние мод высшего порядка и трудностей с расчётом их распространения через систему
  Учитывает только конвертирование наклонного гаусса в наклонного гаусса
  """
  U_2 = MUX_N3(parameter_, U_input_gauss_3_full) # можно менять сторону

  return -float((np.real(np.multiply(np.matmul(np.conj(U_output_2_full).T, U_2), np.matmul(np.conj(U_2).T, U_output_2_full)) ))[0,0]) #-float((np.real(np.multiply(np.matmul(np.conj(U_output_2_full).T, U_2), np.matmul(np.conj(U_2).T, U_output_2_full)) ))[0,0]) -float((np.real(np.multiply(np.matmul(np.conj(U_output_3_full).T, U_3), np.matmul(np.conj(U_3).T, U_output_3_full)) ))[0,0]) )/3

grad_MUX_visualisation(parameter_vector)

"""Исходя из построенных графиков полей обратного и прямого прохождения, для градиента, видно что поле обратное считается некоректно, так как при прямом падении сталкивается с выходным отверстием и создает острые границы, на котором возникают высокачастотные компаненты фурье и как результат считается не правильно!

TODO: Нужно проверить итоговую формулу

#Алгоритм оптимизации
"""

plt.imshow( np.reshape(grad_MUX_normalized(parameter_vector),(N1,N2) ))
plt.colorbar()
plt.show()

plt.imshow( np.reshape(grad_MUX(parameter_vector),(N1,N2) ))
plt.colorbar()
plt.show()

plt.imshow( np.reshape(grad_MUX1_gauss_mode(parameter_vector),(N1,N2) ))
plt.colorbar()
plt.show()

"""**Алгоритм успешно переводит с чистотой за 80% гаусс с любого из 3 входов в гаусс на выходе!**"""

print(-float((np.real(np.multiply(np.matmul(np.conj(U_output_2_full).T, MUX_N3(data, U_input_gauss_2_full)), np.matmul(np.conj(MUX_N3(data, U_input_gauss_2_full)).T, U_output_2_full)) ))[0,0]))

"""Совпадение мод = 1



Для всех остальных <0.5
"""

data = np.load("MUX v3 refractive index modes 0.67.npy")

bnds = ((0, 2*np.pi),)*(N1*N2)
result = minimize(overlap_integral_3_modes, result.x, method='L-BFGS-B',bounds=bnds, jac=grad_MUX_normalized, options={'gtol':1e-25,'ftol':1e-25,'maxiter' : 160})

print(result)# 5 итераций около 12 минут

np.save("MUX v3 refractive index modes plus zero angle 0.58", result.x)

tiks_place_x

import matplotlib as mpl
import matplotlib.ticker as ticker

step = 100

scaler = 1e+6

tiks_place_x = np.linspace(0+step,N1-step,5, endpoint=True, dtype=int)
tiks_place_y = np.linspace(0+step,N2-step,5, endpoint=True, dtype=int)


tiks_value_x = np.round(np.linspace((-N1/2 + step)*T*scaler,(N1/2 - step)*T*scaler ,5, endpoint=True ), decimals=-2)
tiks_value_y = np.round(np.linspace((-N2/2 + step)*T*scaler,(N2/2 - step)*T*scaler, 5, endpoint=True), decimals=-2)



fig, ax = plt.subplots(figsize=(8,8),layout='tight')
ax.yaxis.set_major_locator(ticker.FixedLocator(tiks_place_y))
ax.yaxis.set_major_formatter(ticker.FixedFormatter(tiks_value_y))
ax.xaxis.set_major_locator(ticker.FixedLocator(tiks_place_x))
ax.xaxis.set_major_formatter(ticker.FixedFormatter(tiks_value_x))
ax.set_ylabel('y, мкм')
ax.set_xlabel('x, мкм')
map = ax.imshow(np.reshape(data,(N1,N2)))
fig.colorbar(map,shrink=0.72)
ax.set_title('фазовая маска')
plt.show()

plt.imshow(np.multiply(np.reshape(data,(N1,N2)), press))
plt.colorbar()
plt.title('фазовая маска')
plt.axis()
plt.show()

discrete_mask = discrete_phase(np.reshape(result.x, (N1,N2)))
plt.imshow(discrete_mask)
plt.colorbar()
plt.title('фазовая маска дискретная')
plt.axis()
plt.show()

plt.imshow(np.abs(np.reshape(MUX_N3(data, U_input_gauss_1_full + U_input_gauss_2_full + U_input_gauss_3_full), (N1_full, N2_full)))[880:930,515:565])
plt.colorbar()
plt.title('суммарный выход мод')
plt.show()

plt.imshow(np.real(np.reshape(U_output_3_full, (N1_full, N2_full)))[880:930,515:565])
plt.colorbar()
plt.title('должно быть на выходе 3-ой моды')
plt.show()

grad_MUX_visualisation(result.x)

"""# Анализ работы устройства"""

def single_modes_coef(parameter_, input, output):
  '''
  считает перекрытие мод

  '''
  return -float((np.real(np.multiply(np.matmul(np.conj(output).T, MUX_N3(parameter_, input)), np.matmul(np.conj(MUX_N3(parameter_, input)).T, output)) ))[0,0])

import pandas as pd

def automatic_coeff_matrix_MUX(parameter_):
  """
  На вход принимает вектор фазовой маски

  вывод таблицы будет через pandas
  """

  coef_matrix = pd.DataFrame(columns= ['U_output_1','U_output_2','U_output_3'], index=['U_input_1','U_input_2','U_input_3']) # Как в той статье


  for input_mode, U_input_gauss in [('U_input_1', U_input_gauss_1_full),('U_input_2', U_input_gauss_2_full),('U_input_3', U_input_gauss_3_full)]:
    for output_mode,U_output_mode   in [('U_output_1', U_output_1_full),('U_output_2', U_output_2_full),('U_output_3', U_output_3_full)]:
      coef_matrix.loc[input_mode, output_mode] = single_modes_coef(parameter_, U_input_gauss, U_output_mode)


  return coef_matrix

# работаем над демультиплексором.


def single_modes_coef_DEMUX(parameter_, input, output):
  '''
  считает перекрытие мод в обратную сторону

  output - как матрица !!!!!!
  Чтобы работало при нынешних константах:

  '''
  output = np.reshape(output, (N1_full,N2_full))
  input = np.reshape(input, (N1_full*N2_full,1))

  return -float((np.real(np.multiply(np.matmul(np.conj(input).T, MUX_N3_adjoint_with_phase(parameter_, output)), np.matmul(np.conj(MUX_N3_adjoint_with_phase(parameter_, output)).T, input)) ))[0,0])


def automatic_coeff_matrix_DEMUX(parameter_):
  """
  На вход принимает вектор фазовой маски

  вывод таблицы будет через pandas

  ДЛЯ ДЕМУЛЬТИПЛЕКСОРА
  """

  coef_matrix = pd.DataFrame(columns= ['U_output_1','U_output_2','U_output_3'], index=['U_input_1','U_input_2','U_input_3']) # Как в той статье


  for input_mode, U_input_gauss in [('U_input_1', U_input_gauss_1_full),('U_input_2', U_input_gauss_2_full),('U_input_3', U_input_gauss_3_full)]:
    for output_mode,U_output_mode   in [('U_output_1', U_output_1_full),('U_output_2', U_output_2_full),('U_output_3', U_output_3_full)]:
      coef_matrix.loc[input_mode, output_mode] = -single_modes_coef_DEMUX(parameter_, U_input_gauss, U_output_mode)


  return coef_matrix

print(automatic_coeff_matrix_MUX(data))

print(automatic_coeff_matrix_DEMUX(data))

plt.imshow(np.abs(np.reshape(MUX_N3_adjoint_with_phase(data, U_output_1_full + U_output_2_full + U_output_3_full), (N1_full, N2_full)))[150:180, 270:300]) #[140:180, 250:320]
plt.colorbar()
plt.title('демультиплексор 1 вход при всех модах')
plt.show()

plt.imshow(np.abs(np.reshape(MUX_N3_adjoint_with_phase(data, U_output_1_full + U_output_2_full + U_output_3_full), (N1_full, N2_full)))[150:180, 525:555]) #[140:180, 250:320]
plt.colorbar()
plt.title('демультиплексор 2 вход при всех модах')
plt.show()

plt.imshow(np.abs(np.reshape(MUX_N3_adjoint_with_phase(data, U_output_1_full + U_output_2_full + U_output_3_full), (N1_full, N2_full)))[150:180, 780:810]) #[140:180, 250:320]
plt.colorbar()
plt.title('демультиплексор 3 вход при всех модах')
plt.show()

def MUX_visualisation_first_mode(parameter_):
  """
  версия от 04.03.2025
  принимает ndarray (n,)
  возвращает ndarray (n,)
  """

  U_1_step1 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_1_full),T_mirror(parameter_)))
  U_1_step2 =np.multiply(Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, U_input_gauss_1_full),T_mirror(parameter_))), T_phase(parameter_))
  U_1_step3 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step1, T_phase(parameter_))),T_mirror(parameter_)))
  U_1_step4 = np.multiply(Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step1, T_phase(parameter_))),T_mirror(parameter_))), T_phase(parameter_))

  U_1_step5 = Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step3, T_phase(parameter_))),T_mirror(parameter_)))
  U_1_step6 = np.multiply(Propogator_MUX(parameter_,np.multiply(Propogator_MUX(parameter_, np.multiply(U_1_step3, T_phase(parameter_))),T_mirror(parameter_))), T_phase(parameter_))

  plt.imshow( np.reshape(np.absolute(U_1_step1),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после зеркала')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step2),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после первой фазы')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step3),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после зеркала')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step4),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после второй фазы')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step5),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после зеркала')
  plt.show()

  plt.imshow( np.reshape(np.absolute(U_1_step6),(N1_full,N2_full) ))
  plt.colorbar()
  plt.title('после третьей фазы')
  plt.show()


  #################################




  return  #np.array(np.reshape((2*np.imag(part_1 + part_3 + part_3  )/3)[N_padding:N_padding+N1, N_padding:N_padding+N2], (N1*N2,))) # ОШИБКА , НЕ ТА РАЗМЕРНОСТЬ

MUX_visualisation_first_mode(data)

"""# Импорт мод в lumerical"""

import scipy.io as sio

Whole_dict_input = {'Ex': list(),'Ey': list(), 'Ez': list() , 'x': list(), 'y': list(), 'z': list()}

for columns in range(N_input):
  Whole_dict_input['Ex'].append([])
  Whole_dict_input['Ey'].append([])
  Whole_dict_input['Ez'].append([])
  Whole_dict_input['x'].append(float(x_arr[columns]))
  Whole_dict_input['y'].append(float(y_arr[columns]))

  for rows in range(N_input):
    Whole_dict_input['Ex'][columns].append(complex(U_input_gauss[columns,rows]))
    Whole_dict_input['Ey'][columns].append(0)
    Whole_dict_input['Ez'][columns].append(0)

Whole_dict_input['z'].append(0)

Whole_dict_input['Ex']

sio.savemat('Input_mode_mat', {'featureSet':Whole_dict_input})

simple_dic = {'zob': list()}

zob = 112
simple_dic['z'].append(zob)
sio.savemat('simple_example 1', {'featureSet':simple_dic})



def discrete_phase(mask):
  """
  Фугнкция дискретизации на D возможных значений, по логике близости по модулю
  На вход ndarray
  Выход ndarray
  phase set можно установить на основе уже имеющихся метаатомов.
  """
  D = 10
  phase_set = np.linspace(0,2*np.pi - 0.34, D, endpoint=True)
  discrete_mask = np.zeros(mask.shape)
  for i in range(mask.shape[0]):
    for j in range(mask.shape[1]):
      discrete_mask[i,j] = phase_set[np.argmin (np.abs(phase_set - mask[i,j]))]
  return discrete_mask

def interpolate_2(arr):
  '''
  На вход принимает массив размером N1*N2

  На выходе массив размером 2*N1*N2*2

  Идея: использовать массив ближайших соседей
  '''
  near_i = [-1,-1, 0]
  near_j = [0, 1, 1]
  arr = np.reshape(arr, (N1,N2))
  arr_max = np.zeros((2*N1,2*N2))

  for i in range(0, N1): # только по чётным
    for j in range(0, N2):
      arr_max[2*i,2*j] = arr[i,j]
      for k in [0,1,2]:
        arr_max[2*i + near_i[k],2*j + near_j[k]] = arr[i,j]

  return arr_max

plt.imshow(np.real(np.reshape(data, (N1, N2))))
plt.colorbar()
plt.title(' фазовая маска')
plt.show()

data2 = interpolate_2(data)

plt.imshow(np.real(np.reshape(interpolate_2(data), (N1*2, N2*2))))
plt.colorbar()
plt.title('интерполированная фазовая маска')
plt.show()

discrete_mask = discrete_phase(np.reshape(data2, (2*N1,2*N2)))
plt.imshow(discrete_mask)
plt.colorbar()
plt.title('фазовая маска дискретная интерполированная')
plt.axis()
plt.show()

"""**Нужно возвращать номера дисков из массива, чтобы быстро строить диски. Нужно бы определиться с размером столбиков.**"""

# считываем зависимости через текст:
graph = open('23_april_phase_radii_5_95_graph.txt', 'r')

data = np.load("MUX v3 refractive index modes 0.67.npy")

graph_list = []
for line in graph.readlines():
  print(line)
  if line.strip():
    graph_list.append(line.strip().split())
graph_list = np.array(graph_list)

graph_list
radius_set = []
phase_set = []
for i in range(1, graph_list.shape[0]):
  radius_set.append(float(graph_list[i][0].strip(',')))
  phase_set.append(float(graph_list[i][1].strip(',')))

phase_set = np.array(phase_set) - min(phase_set)

phase_set

plt.plot(radius_set, phase_set)
plt.xlabel('radius, nm')
plt.ylabel('phase, rad')
plt.title('phase(radius) for nanopillars')
plt.show()

def discrete_phase_experiment(mask, phase, radii):
  """
  Фугнкция дискретизации на D возможных значений, по логике близости по модулю
  На вход ndarray
  Выход ndarray

  Возвращает набор фаз дисков и набор радиусов дисков
  phase set можно установить на основе уже имеющихся метаатомов.
  """

  D = 10
  # Сначала мы просеиваем зависимость фазы от параметра метаатомов и находим необходимый набор для равномерной фазы

  phase_sparse = np.linspace(min(phase),max(phase), D, endpoint=True)
  phase_set = np.zeros(phase_sparse.shape)
  set_of_radius = np.zeros(phase_sparse.shape)
  #print(phase_sparse)
  for i in range(len(phase_sparse)):
    phase_set[i] = phase[np.argmin(np.abs(phase - phase_sparse[i]))]
    set_of_radius[i] = radii[np.argmin(np.abs(phase_sparse[i] - phase))]

  discrete_mask_radii = np.zeros(mask.shape)
  discrete_mask_phase = np.zeros(mask.shape)
  for i in range(mask.shape[0]):
    for j in range(mask.shape[1]):
      discrete_mask_phase[i,j] = phase_set[np.argmin (np.abs(phase_set - mask[i,j]))]
      discrete_mask_radii[i,j] = set_of_radius[np.argmin (np.abs(phase_set - mask[i,j]))]
  return discrete_mask_phase,discrete_mask_radii ,phase_set, set_of_radius

mask_1,mask_r, phase_1, radii_1 = discrete_phase_experiment(np.reshape(data2, (2*N1,2*N2)),  phase_set, radius_set)

radii_1

final_table,_,_,_ = discrete_phase_experiment(np.reshape(data, (N1,N2)),  phase_set, radius_set)

plt.imshow(mask_1)
plt.colorbar()
plt.title('фазовая маска итоговая')
plt.axis()
plt.show()

# Расчёт качества для финальной маски
print(automatic_coeff_matrix_MUX(final_table))

print(automatic_coeff_matrix_MUX(np.reshape(discrete_phase(np.reshape(data,(N1,N2))), (N1*N2,1))))

print(automatic_coeff_matrix_MUX(data))

"""**Очень хорошая идея: отправлять на сервер массив радиусов.**"""

np.save('full_60_54_61_radii_mask_23_april', mask_r)

#создание сетки для входа
T_e = 500e-9
if (2*N1)%2==0: x_start = -((2*N1)/2 -1)*T_e - T_e/2
else: x_start = -((2*N1)-1)/2*T_e

if (2*N1)%2==0: x_stop = ((2*N1)/2 -1)*T_e + T_e/2
else: x_stop = ((2*N1)-1)/2*T_e

x_arr = np.linspace( x_start,x_stop , num =2*N1,endpoint=True)
y_arr = np.linspace( x_start,x_stop , num =2*N2,endpoint=True)

x_arr[-1]

"""проверка, нужно глянуть сколько элементов и какая разница между ними - так как число дисков точно чётное, то первый элемент должен быть расположен на расстоянии: +- T/2 +- N*T и всего элементов N*2"""